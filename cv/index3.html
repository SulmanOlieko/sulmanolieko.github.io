<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced PDF Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Import the same Poppins font used on the website for visual consistency -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap">

  <!-- PDF.js library and worker -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.5.141/pdf.min.js"></script>
  <script>
    // Configure worker path for PDF.js.  Without this the worker must be
    // downloaded each time the viewer is used.
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.5.141/pdf.worker.min.js';
  </script>

  <style>
    :root {
      /* Pull the primary colours from sulmanolieko.github.io theme.  These
         variables define the core palette for the viewer and can be tweaked
         easily to stay in sync with future redesigns. */
      --primary-color: #795548;
      --primary-hover: #49332b;
      --background-color: #f8f9fa;
      --text-color: #212529;
      --sidebar-width: 220px;
      --toolbar-height: 50px;
    }

    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      color: var(--text-color);
      background-color: var(--background-color);
      overflow: hidden;
    }

    /* Top toolbar styling */
    #toolbar {
      display: flex;
      align-items: center;
      height: var(--toolbar-height);
      padding: 0 10px;
      background-color: var(--primary-color);
      color: #fff;
    }

    #toolbar button,
    #toolbar input,
    #toolbar span {
      margin-right: 8px;
    }

    #toolbar button {
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #toolbar button:hover {
      background-color: var(--primary-hover);
    }

    #toolbar input[type='number'] {
      width: 60px;
      padding: 4px;
      border-radius: 4px;
      border: none;
    }

    #toolbar input[type='text'] {
      padding: 4px 6px;
      border-radius: 4px;
      border: none;
      width: 200px;
    }

    #search_info {
      margin-left: 4px;
      font-size: 14px;
    }

    /* Layout container: sidebar + viewer */
    #container {
      display: flex;
      height: calc(100vh - var(--toolbar-height));
      overflow: hidden;
    }

    /* Sidebar styling */
    #sidebar {
      width: var(--sidebar-width);
      background-color: #fff;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    /* Collapsed sidebar is translated off screen */
    #sidebar.collapsed {
      transform: translateX(calc(-1 * var(--sidebar-width)));
    }

    #sidebar .sidebar-section {
      border-bottom: 1px solid #eee;
    }

    #sidebar .section-header {
      padding: 8px 12px;
      background-color: var(--primary-color);
      color: #fff;
      cursor: pointer;
      font-weight: 500;
    }

    #sidebar .section-content {
      padding: 8px;
      display: none;
    }

    #sidebar .section-content.active {
      display: block;
    }

    /* Outline list */
    #outlineList {
      list-style: none;
      padding-left: 0;
    }

    #outlineList li {
      margin: 4px 0;
      cursor: pointer;
    }

    #outlineList li:hover {
      text-decoration: underline;
    }

    /* Attachments list */
    #attachList {
      list-style: none;
      padding-left: 0;
    }

    #attachList li {
      margin: 4px 0;
    }

    /* Thumbnails container */
    #thumbsList {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #thumbsList canvas {
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
    }

    #thumbsList canvas.active {
      border-color: var(--primary-color);
    }

    /* Viewer container */
    #viewerContainer {
      flex-grow: 1;
      overflow: auto;
      background-color: var(--background-color);
      position: relative;
    }

    /* Page container holds canvas and text layer */
    #pageContainer {
      position: relative;
      margin: auto;
      padding: 10px;
    }

    /* Canvas for PDF page */
    #pdfCanvas {
      display: block;
      margin: 0 auto;
      background-color: #fff;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }

    /* Text layer overlay.  It needs pointer events disabled so that clicking
       through to the canvas works normally. */
    #textLayer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    #textLayer .highlight {
      background-color: yellow;
      border-radius: 2px;
    }
  </style>
</head>
<body>
  <!-- Top toolbar with navigation, zoom, search, download and fullscreen controls -->
  <div id="toolbar">
    <button id="toggleSidebar" title="Toggle sidebar">&#9776;</button>
    <button id="prev" title="Previous page">&#8592;</button>
    <button id="next" title="Next page">&#8594;</button>
    <span>Page <input type="number" id="page_num" min="1"> / <span id="page_count">--</span></span>
    <button id="zoom_out" title="Zoom out">&#8722;</button>
    <button id="zoom_in" title="Zoom in">&#43;</button>
    <input type="text" id="search_input" placeholder="Search...">
    <button id="search_btn" title="Find text">Search</button>
    <span id="search_info"></span>
    <button id="downloadBtn" title="Download">&#10515;</button>
    <button id="fullscreenBtn" title="Fullscreen">&#x26F6;</button>
  </div>

  <!-- Main container splits sidebar and viewer -->
  <div id="container">
    <div id="sidebar" class="collapsed">
      <div class="sidebar-section">
        <div class="section-header" data-target="outlineList">Outline</div>
        <ul id="outlineList" class="section-content"></ul>
      </div>
      <div class="sidebar-section">
        <div class="section-header" data-target="thumbsList">Thumbnails</div>
        <div id="thumbsList" class="section-content"></div>
      </div>
      <div class="sidebar-section">
        <div class="section-header" data-target="attachList">Attachments</div>
        <ul id="attachList" class="section-content"></ul>
      </div>
    </div>
    <div id="viewerContainer">
      <div id="pageContainer">
        <canvas id="pdfCanvas"></canvas>
        <div id="textLayer" class="textLayer"></div>
      </div>
    </div>
  </div>

  <script>
    // PDF data and state
    let pdfDoc = null;
    let pageNum = 1;
    let scale = 1.0;
    let pageRendering = false;
    let pageNumPending = null;
    let currentQuery = '';
    // caches for thumbnails to avoid re-rendering
    const thumbCache = {};

    // Default file to open.  If your viewer is deployed on a web server,
    // specify a valid PDF here or provide a 'file' query parameter in the URL.
    const DEFAULT_URL = 'sample.pdf';

    const canvas = document.getElementById('pdfCanvas');
    const ctx = canvas.getContext('2d');
    const textLayerDiv = document.getElementById('textLayer');

    /**
     * Render a page with given number.
     * This function renders the page onto the canvas, populates the text layer
     * and applies search highlighting if a query is active.
     */
    function renderPage(num) {
      pageRendering = true;
      pdfDoc.getPage(num).then(function(page) {
        const viewport = page.getViewport({ scale: scale });
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        // Adjust the container size so that the text layer positions correctly
        document.getElementById('pageContainer').style.width = viewport.width + 'px';
        document.getElementById('pageContainer').style.height = viewport.height + 'px';

        const renderContext = {
          canvasContext: ctx,
          viewport: viewport
        };
        const renderTask = page.render(renderContext);

        // Clear previous text layer
        while (textLayerDiv.firstChild) {
          textLayerDiv.removeChild(textLayerDiv.firstChild);
        }

        // After rendering the canvas, render the text layer
        renderTask.promise.then(function() {
          page.getTextContent().then(function(textContent) {
            pdfjsLib.renderTextLayer({
              textContent: textContent,
              container: textLayerDiv,
              viewport: viewport,
              textDivs: []
            }).promise.then(function() {
              // Apply highlighting if there is a current search term
              highlightSearch(textLayerDiv, currentQuery);
              pageRendering = false;
              document.getElementById('page_num').value = num;
              document.getElementById('page_count').textContent = pdfDoc.numPages;
              // Update active thumbnail
              updateActiveThumbnail(num);
              if (pageNumPending !== null) {
                const pending = pageNumPending;
                pageNumPending = null;
                renderPage(pending);
              }
            });
          });
        });
      });
    }

    /**
     * Queue a page render.  If another page is currently rendering, store the
     * requested page number and call renderPage once ready.
     */
    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(num);
      }
    }

    // Navigation functions
    function onPrevPage() {
      if (pageNum <= 1) return;
      pageNum--;
      queueRenderPage(pageNum);
    }
    function onNextPage() {
      if (pageNum >= pdfDoc.numPages) return;
      pageNum++;
      queueRenderPage(pageNum);
    }
    function onZoomIn() {
      scale = scale * 1.25;
      queueRenderPage(pageNum);
      // regenerate thumbnails if necessary
      generateThumbnails();
    }
    function onZoomOut() {
      scale = scale / 1.25;
      queueRenderPage(pageNum);
      generateThumbnails();
    }
    function onGoToPage(e) {
      const val = parseInt(e.target.value);
      if (!val || val < 1 || val > pdfDoc.numPages) return;
      pageNum = val;
      queueRenderPage(pageNum);
    }

    /**
     * Search across the entire document for the query.  Stores the query and
     * updates the search info.  When rendering pages the matches will be
     * highlighted via highlightSearch().
     */
    async function performSearch(query) {
      currentQuery = query.trim().toLowerCase();
      if (!currentQuery) {
        document.getElementById('search_info').textContent = '';
        renderPage(pageNum);
        return;
      }
      let matchesCount = 0;
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const content = await page.getTextContent();
        const text = content.items.map(item => item.str).join(' ').toLowerCase();
        if (text.includes(currentQuery)) {
          matchesCount++;
        }
      }
      document.getElementById('search_info').textContent = matchesCount + ' page(s) found';
      // Refresh current page to show highlights
      queueRenderPage(pageNum);
    }

    /**
     * Highlight search term occurrences inside the given text layer.  This
     * function loops through each text node and wraps matches in a span with
     * the highlight class.  The highlighting is case-insensitive.
     */
    function highlightSearch(textLayer, query) {
      if (!query) return;
      const regExp = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      const textDivs = textLayer.querySelectorAll('span');
      textDivs.forEach(span => {
        const text = span.textContent;
        if (!text) return;
        if (regExp.test(text)) {
          span.innerHTML = text.replace(regExp, match => `<span class="highlight">${match}</span>`);
        }
      });
    }

    /**
     * Populate the outline (table of contents) panel.  Outline items may
     * reference named destinations or explicit page numbers.  Clicking on an
     * item navigates to that location.
     */
    async function populateOutline() {
      const outline = await pdfDoc.getOutline();
      const list = document.getElementById('outlineList');
      list.innerHTML = '';
      if (!outline) return;
      outline.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item.title;
        li.addEventListener('click', async () => {
          if (item.dest) {
            const dest = await pdfDoc.getDestination(item.dest);
            const pageIndex = (await pdfDoc.getPageIndex(dest[0])) + 1;
            pageNum = pageIndex;
            queueRenderPage(pageNum);
          } else if (item.url) {
            window.open(item.url, '_blank');
          }
        });
        list.appendChild(li);
      });
    }

    /**
     * Populate attachments list if the document contains embedded files.
     */
    async function populateAttachments() {
      const attachments = await pdfDoc.getAttachments();
      const list = document.getElementById('attachList');
      list.innerHTML = '';
      if (!attachments) return;
      for (const key of Object.keys(attachments)) {
        const item = attachments[key];
        const li = document.createElement('li');
        const link = document.createElement('a');
        link.href = URL.createObjectURL(new Blob([item.content], { type: item.contentType }));
        link.download = item.filename;
        link.textContent = item.filename;
        li.appendChild(link);
        list.appendChild(li);
      }
    }

    /**
     * Generate thumbnails for all pages at a small scale.  Thumbnails are cached
     * to avoid repeated rendering.  Clicking on a thumbnail navigates to the
     * corresponding page.
     */
    function generateThumbnails() {
      const thumbsContainer = document.getElementById('thumbsList');
      thumbsContainer.innerHTML = '';
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const canvasThumb = document.createElement('canvas');
        canvasThumb.width = 80;
        canvasThumb.height = 100;
        canvasThumb.classList.add('thumbnail');
        if (i === pageNum) canvasThumb.classList.add('active');
        canvasThumb.addEventListener('click', () => {
          pageNum = i;
          queueRenderPage(i);
        });
        thumbsContainer.appendChild(canvasThumb);
        // If cached, draw from cache; otherwise, render a thumbnail
        if (thumbCache[i]) {
          const ctxThumb = canvasThumb.getContext('2d');
          ctxThumb.drawImage(thumbCache[i], 0, 0, canvasThumb.width, canvasThumb.height);
        } else {
          pdfDoc.getPage(i).then(page => {
            const viewport = page.getViewport({ scale: 0.2 });
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = viewport.width;
            thumbCanvas.height = viewport.height;
            const thumbContext = thumbCanvas.getContext('2d');
            page.render({ canvasContext: thumbContext, viewport: viewport }).promise.then(() => {
              thumbCache[i] = thumbCanvas;
              const ctxThumb = canvasThumb.getContext('2d');
              ctxThumb.drawImage(thumbCanvas, 0, 0, canvasThumb.width, canvasThumb.height);
            });
          });
        }
      }
    }

    /**
     * Update active thumbnail highlight when page changes.
     */
    function updateActiveThumbnail(current) {
      const canvases = document.querySelectorAll('#thumbsList canvas');
      canvases.forEach((c, idx) => {
        c.classList.toggle('active', idx + 1 === current);
      });
    }

    /**
     * Populate the download link with the current document URL.  If the file
     * parameter is set, it will be used; otherwise the default.
     */
    function setDownloadLink(url) {
      const downloadBtn = document.getElementById('downloadBtn');
      downloadBtn.onclick = () => {
        const a = document.createElement('a');
        a.href = url;
        a.download = url.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };
    }

    /**
     * Toggle full screen mode for the document container.  When the user
     * presses the fullscreen button, request fullscreen on viewerContainer.
     */
    function toggleFullScreen() {
      const container = document.documentElement;
      if (!document.fullscreenElement) {
        container.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    /**
     * Load a PDF from a given URL.  After loading, populate the sidebar
     * contents and render the first page.
     */
    function loadPdf(url) {
      pdfjsLib.getDocument(url).promise.then(function(pdf) {
        pdfDoc = pdf;
        pageNum = 1;
        document.getElementById('page_count').textContent = pdfDoc.numPages;
        document.getElementById('page_num').max = pdfDoc.numPages;
        // Populate controls
        populateOutline();
        populateAttachments();
        generateThumbnails();
        setDownloadLink(url);
        renderPage(pageNum);
      }).catch(function(error) {
        console.error('Error loading PDF:', error);
      });
    }

    /**
     * Determine file parameter from query string.  If not present, return null.
     */
    function getQueryParameter(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    // Event listeners
    document.getElementById('prev').addEventListener('click', onPrevPage);
    document.getElementById('next').addEventListener('click', onNextPage);
    document.getElementById('zoom_in').addEventListener('click', onZoomIn);
    document.getElementById('zoom_out').addEventListener('click', onZoomOut);
    document.getElementById('page_num').addEventListener('change', onGoToPage);
    document.getElementById('search_btn').addEventListener('click', function() {
      performSearch(document.getElementById('search_input').value);
    });
    document.getElementById('search_input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        performSearch(e.target.value);
      }
    });
    document.getElementById('downloadBtn').addEventListener('click', function() {
      // The actual download click handler is assigned by setDownloadLink()
    });
    document.getElementById('fullscreenBtn').addEventListener('click', toggleFullScreen);

    // Sidebar toggle
    document.getElementById('toggleSidebar').addEventListener('click', function() {
      document.getElementById('sidebar').classList.toggle('collapsed');
    });

    // Collapsible section headers inside the sidebar
    const sectionHeaders = document.querySelectorAll('#sidebar .section-header');
    sectionHeaders.forEach(header => {
      header.addEventListener('click', () => {
        const targetId = header.getAttribute('data-target');
        const content = document.getElementById(targetId);
        content.classList.toggle('active');
      });
    });

    // Determine which file to load
    const fileParam = getQueryParameter('file');
    if (fileParam) {
      loadPdf(fileParam);
    } else {
      loadPdf(DEFAULT_URL);
    }
  </script>
</body>
</html>