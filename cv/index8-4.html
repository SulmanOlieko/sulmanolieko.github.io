<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scrollable PDF Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Use Poppins to match the siteâ€™s typography -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap">
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="../css/font-awesome.min.css">

  <!-- Include PDF.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.5.141/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.5.141/pdf.worker.min.js';
  </script>

  <style>
    :root {
      --primary-color: #795548;
      --primary-hover: #49332b;
      --background-color: #f8f9fa;
      --text-color: #212529;
      --sidebar-width-large: 20%;
      --sidebar-width-small: 90%;
      --sidebar-width: var(--sidebar-width-large);
      --toolbar-height: 50px;
      --outline-font-size: 0.8rem;
    }

    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background-color: var(--background-color);
      color: var(--text-color);
      overflow: auto; /* Allow body to scroll */
    }

    /* Toolbar styling */
    #toolbar {
      display: flex;
      align-items: center;
      height: var(--toolbar-height);
      padding: 0 10px;
      background-color: var(--primary-color);
      color: #fff;
      z-index: 100;
    }
    #toolbar button,
    #toolbar input,
    #toolbar span {
      margin-right: 8px;
    }
    #toolbar button {
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      padding: 6px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    #toolbar button:hover {
      background-color: var(--primary-hover);
    }
    #toolbar input[type="number"] {
      width: 60px;
      padding: 4px;
      border-radius: 4px;
      border: none;
    }
    #toolbar input[type="text"] {
      padding: 4px 6px;
      border-radius: 4px;
      border: none;
      width: 200px;
    }

    /* Layout wrapper */
    #container {
      display: flex;
    }

    /* Sidebar with tabs for outline and thumbnails */
    #sidebar {
      width: var(--sidebar-width);
      flex-basis: var(--sidebar-width);
      background-color: #fff;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }
    #sidebar.collapsed {
      /* Collapse sidebar completely by reducing width/flex-basis to zero */
      transform: translateX(0);
      width: 0 !important;
      flex-basis: 0 !important;
    }
    #sidebarTabs {
      display: flex;
      justify-content: space-around;
      border-bottom: 1px solid #ddd;
      background-color: var(--background-color);
      padding: 5px 0;
    }
    #sidebarTabs button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--primary-color);
    }
    #sidebarTabs button.active {
      color: var(--primary-hover);
    }
    /* Content areas inside sidebar */
    .sidebar-content {
      display: none;
      padding: 8px;
    }
    .sidebar-content.active {
      display: block;
    }
    /* Outline file tree */
    #outlineList {
      list-style: none;
      padding-left: 0;
      font-size: var(--outline-font-size);
    }
    #outlineList li {
      cursor: pointer;
      margin: 4px 0;
    }
    #outlineList li:hover {
      text-decoration: underline;
    }
    /* Indent nested outlines */
    #outlineList .level-1 { margin-left: 10px; }
    #outlineList .level-2 { margin-left: 20px; }
    #outlineList .level-3 { margin-left: 30px; }

    /* Thumbnails */
    /* Hide thumbnails container by default; it will be shown when active */
    #thumbsList {
      display: none;
      flex-direction: column;
      align-items: center;
    }
    #thumbsList.active {
      display: flex;
    }
    .thumb-item {
      margin-bottom: 10px;
      text-align: center;
      cursor: pointer;
      position: relative;
      width: 100%;
      margin-left: auto;
      margin-right: auto;
    }
    .thumb-item canvas {
      border: 1px solid #ccc;
      border-radius: 4px;
      width: 80%;
      height: auto;
    }
    .thumb-item.active canvas {
      border: 2px solid var(--primary-color);
    }
    .thumb-item.active .page-number {
      color: var(--primary-color);
      font-weight: bold;
      border: 1px solid var(--primary-color);
      border-radius: 4px;
      padding: 2px;
      display: inline-block;
    }
    /* Page number displayed below each thumbnail rather than overlay */
    .thumb-item .page-number {
      margin-top: 4px;
      font-size: 12px;
      color: #333;
    }

    /* Divider style */
    #divider {
      width: 4px;
      background-color: #ddd;
      cursor: col-resize;
    }

    /* Backdrop for mobile sidebar */
    #backdrop {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      z-index: 400;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      :root {
        --toolbar-height: 45px;
      }
      #sidebar {
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        width: var(--sidebar-width-small);
        flex-basis: auto;
        z-index: 500;
        transform: translateX(-100%);
        transition: transform 0.3s ease;
      }
      #sidebar.collapsed {
        transform: translateX(-100%);
      }
      #sidebar:not(.collapsed) {
        transform: translateX(0);
      }
      #container {
        flex-direction: row; /* Back to row for mobile overlay */
      }
      #viewerContainer {
        flex-grow: 1;
        height: calc(100vh - var(--toolbar-height));
      }
      #toolbar button, #toolbar input, #toolbar span {
        margin-right: 4px;
      }
      #toolbar input[type="text"] {
        width: 120px;
      }
      #divider {
        display: none !important; /* Divider not needed on mobile */
      }
    }

    /* Bottom page navigation */
    #pageNavigation {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.2);
      color: #fff;
      padding: 6px 12px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 300;
      font-size: 14px;
      backdrop-filter: blur(4px);
    }
    #pageNavigation button {
      background: none;
      border: none;
      color: inherit;
      font-size: 18px;
      cursor: pointer;
      padding: 0 6px;
    }

    /* Search bar (CloudPDF-like) */
    #searchBar {
      display: none;
      position: relative;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 6px 10px;
      border-bottom: 1px solid #ddd;
      align-items: center;
      gap: 6px;
      z-index: 250;
    }
    #searchBar input {
      flex-grow: 1;
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-family: 'Poppins', sans-serif;
    }
    #searchBar button {
      background: none;
      border: none;
      color: var(--primary-color);
      font-size: 18px;
      cursor: pointer;
      padding: 2px 6px;
    }
    #searchBar span {
      font-size: 14px;
      color: var(--text-color);
      white-space: nowrap;
    }

    /* Viewer container: holds all pages, scrollable */
    #viewerContainer {
      margin: 0 auto; /* Center the viewer */
      padding: 20px;
      position: relative;
    }
    .pdf-page {
      position: relative;
      margin-bottom: 20px;
      box-shadow: 0 0 5px rgba(0,0,0,0.2);
      background-color: #fff;
    }
    .pdf-page canvas.pdfCanvas {
      width: 100%;
      height: auto;
      display: block;
    }
    .pdf-page canvas.hlCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
      pointer-events: none;
    }
    /* Loader styles */
    #loader {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 999;
    }
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="loader" style="display: none;"></div>
  <div id="backdrop" style="display: none;"></div>
  <div id="toolbar">
    <button id="toggleSidebar" title="Toggle sidebar"><i class="fa fa-bars"></i></button>
    <!-- Removed prev/next buttons from toolbar -->
    <!-- Page navigation removed from toolbar; moved to floating nav -->
    <button id="zoom_out"><i class="fa fa-search-minus"></i></button>
    <button id="zoom_in"><i class="fa fa-search-plus"></i></button>
    <button id="fit_width" title="Fit to width"><i class="fa fa-arrows-h"></i></button>
    <button id="fit_page" title="Fit to page"><i class="fa fa-arrows-v"></i></button>
    <!-- Search icon opens search bar -->
    <button id="openSearchBtn" title="Search"><i class="fa fa-search"></i></button>
    <!-- Rotate controls -->
    <button id="rotate_left" title="Rotate left"><i class="fa fa-rotate-left"></i></button>
    <button id="rotate_right" title="Rotate right"><i class="fa fa-rotate-right"></i></button>
    <button id="downloadBtn" title="Download"><i class="fa fa-download"></i></button>
    <button id="fullscreenBtn" title="Fullscreen"><i class="fa fa-expand"></i></button>
    <!-- floating search navigation added later -->
  </div>

  <!-- Collapsible search bar (appears when search icon is clicked) -->
  <div id="searchBar">
    <input type="text" id="searchBarInput" placeholder="Search...">
    <button id="searchBarPrev" title="Previous result"><i class="fa fa-chevron-left"></i></button>
    <button id="searchBarNext" title="Next result"><i class="fa fa-chevron-right"></i></button>
    <span id="searchBarInfo"></span>
    <button id="searchBarClose" title="Close search"><i class="fa fa-times"></i></button>
  </div>

  <div id="container">
    <div id="sidebar" class="collapsed">
      <div id="sidebarTabs">
        <button id="outlineToggle" title="Outline"><i class="fa fa-list-ul"></i></button>
        <button id="thumbToggle" title="Thumbnails"><i class="fa fa-th-large"></i></button>
      </div>
      <div id="outlineList" class="sidebar-content"></div>
      <div id="thumbsList" class="sidebar-content"></div>
    </div>
    <!-- Divider between sidebar and viewer for resizing -->
    <div id="divider" style="width:4px;cursor:col-resize; background-color:#ddd; display:none;"></div>
    <div id="viewerContainer">
      <div id="errorMessage" style="display:none;color:red;margin:10px;"></div>
    </div>
  </div>

  <!-- Floating bottom navigation for page control -->
  <div id="pageNavigation" style="display:none;">
    <button id="pagePrev"><i class="fa fa-arrow-left"></i></button>
    <span id="pageInfo">-- / --</span>
    <button id="pageNext"><i class="fa fa-arrow-right"></i></button>
  </div>

  <script>
    let pdfDoc = null;
    let pages = [];
    let scale = 1.0;
    let currentQuery = '';
    let rotation = 0;
    // Debounce timer for search
    let searchTimeout = null;

    // Current page tracking
    let currentPage = 1;
    let totalPages = 0;

    // Mode to determine how scale is computed: 'width', 'page', or 'custom'
    let fitMode = 'width';
    // Search result management
    let searchResults = [];
    let currentSearchIndex = -1;
    // Intersection observer for lazy rendering
    let observer = null;
    // Intersection observer for lazy-loading thumbnails
    let thumbnailObserver = null;
    // Thumbnails cache
    const thumbCache = {};

    // Default PDF: change or override via ?file=
    const DEFAULT_URL = 'sample.pdf';

    /**
     * Render all pages of the document at the current scale.  Creates
     * individual page containers with a PDF canvas and a separate highlight
     * canvas on top.  Stores each page's text content for later search.
     */
    async function renderAllPages() {
      console.log('renderAllPages called.');
      const viewer = document.getElementById('viewerContainer');
      // Clear previous pages and disconnect observer
      viewer.innerHTML = '<div id="errorMessage" style="display:none;color:red;margin:10px;"></div>';
      if (observer) observer.disconnect();
      pages = [];
      // Set a default scale for high-quality rendering, unless a custom scale is already set
      if (fitMode !== 'custom') {
        scale = 1.5;
      }
      // Create page containers without rendering; lazy render via IntersectionObserver
      for (let i = 1; i <= pdfDoc.numPages; i++) {
        const page = await pdfDoc.getPage(i);
        const viewport = page.getViewport({ scale: scale, rotation: rotation });
        const pageDiv = document.createElement('div');
        pageDiv.classList.add('pdf-page');
        pageDiv.setAttribute('data-page-number', i);
        // Create canvases
        const canvas = document.createElement('canvas');
        canvas.classList.add('pdfCanvas');
        const hlCanvas = document.createElement('canvas');
        hlCanvas.classList.add('hlCanvas');
        
        // High-quality rendering
        const qualityFactor = 1.5;
        const ratio = window.devicePixelRatio || 1;
        
        // Set actual pixel dimensions for high quality
        canvas.width = viewport.width * ratio * qualityFactor;
        canvas.height = viewport.height * ratio * qualityFactor;
        hlCanvas.width = viewport.width * ratio;
        hlCanvas.height = viewport.height * ratio;

        // Set CSS display size
        canvas.style.width = viewport.width + 'px';
        canvas.style.height = viewport.height + 'px';
        hlCanvas.style.width = viewport.width + 'px';
        hlCanvas.style.height = viewport.height + 'px';
        
        const context = canvas.getContext('2d');
        const hlContext = hlCanvas.getContext('2d');
        
        // Scale contexts for high quality
        context.scale(ratio * qualityFactor, ratio * qualityFactor);
        hlContext.scale(ratio, ratio);
        
        pageDiv.appendChild(canvas);
        pageDiv.appendChild(hlCanvas);
        viewer.appendChild(pageDiv);
        const textContent = await page.getTextContent();
        pages.push({ page, viewport, canvas, context, hlCanvas, hlContext, textContent, rendered: false });
      }
      // Setup intersection observer to render pages when visible
      const options = {
        root: viewer,
        rootMargin: '100px',
        threshold: 0.1
      };
      observer = new IntersectionObserver(entries => {
        let visiblePages = [];
        entries.forEach(entry => {
          const pageNumber = parseInt(entry.target.getAttribute('data-page-number'));
          if (entry.isIntersecting) {
            renderPage(pageNumber);
            visiblePages.push({ pageNumber, ratio: entry.intersectionRatio });
          }
        });

        if (visiblePages.length > 0) {
          // Find the page with the highest intersection ratio
          visiblePages.sort((a, b) => b.ratio - a.ratio);
          const newCurrentPage = visiblePages[0].pageNumber;

          if (newCurrentPage !== currentPage) {
            currentPage = newCurrentPage;
            updatePageInfo();
            updateActiveThumbnail(currentPage);

            // Scroll sidebar to the active thumbnail
            const activeThumb = document.querySelector(`.thumb-item[data-page-number="${currentPage}"]`);
            if (activeThumb) {
              activeThumb.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
          }
        }
      }, options);
      document.querySelectorAll('.pdf-page').forEach(div => observer.observe(div));
      // Generate thumbnails and outline
      generateThumbnails();
      populateOutline();
      // Update total pages in navigation info
      totalPages = pdfDoc.numPages;
      updatePageInfo();
      // Show page navigation control
      const pageNav = document.getElementById('pageNavigation');
      if (pageNav) pageNav.style.display = 'flex';
    }

    /**
     * Highlight search matches on a particular page.  Clears previous
     * highlights on that page's highlight canvas and draws semi-transparent
     * rectangles where the query appears.
     */
    function highlightPage(pageIndex) {
      if (!currentQuery) return;
      const pageObj = pages[pageIndex - 1];
      const { textContent, hlCanvas, hlContext, viewport } = pageObj;
      // Clear previous highlights
      hlContext.clearRect(0, 0, hlCanvas.width, hlCanvas.height);
      const query = currentQuery.toLowerCase();
      const items = textContent.items;
      items.forEach(item => {
        const text = item.str;
        if (!text) return;
        const lowerText = text.toLowerCase();
        let startIndex = 0;
        while (true) {
          const idx = lowerText.indexOf(query, startIndex);
          if (idx === -1) break;
          // Compute highlight box
          const transform = pdfjsLib.Util.transform(viewport.transform, item.transform);
          const x = transform[4];
          // y coordinate: PDF.js defines transform[5] as baseline; adjust by height
          const y = transform[5] - item.height * scale;
          // width per character
          const charWidth = (item.width * scale) / text.length;
          const highlightWidth = charWidth * query.length;
          const highlightX = x + charWidth * idx;
          const highlightY = y;
          const highlightHeight = item.height * scale;
          hlContext.fillStyle = 'rgba(255, 255, 0, 0.4)';
          hlContext.fillRect(highlightX, highlightY, highlightWidth, highlightHeight);
          startIndex = idx + query.length;
        }
      });
    }

    /**
     * Render a specific page if it hasn't been rendered yet.  Uses the stored
     * page object and viewport to draw the PDF image.  After rendering, it
     * applies highlights if there is a current search query.
     */
    function renderPage(pageIndex) {
      const pageObj = pages[pageIndex - 1];
      if (!pageObj || pageObj.rendered) return;
      const { page, viewport, canvas, context } = pageObj;
      page.render({ canvasContext: context, viewport: viewport }).promise.then(() => {
        pageObj.rendered = true;
        if (currentQuery) highlightPage(pageIndex);
      });
    }

    /**
     * Apply highlights across all pages based on currentQuery.  Called after
     * performing a search.
     */
    function highlightAllPages() {
      if (!currentQuery) {
        // Clear all highlight canvases
        pages.forEach(p => p.hlContext.clearRect(0, 0, p.hlCanvas.width, p.hlCanvas.height));
        return;
      }
      pages.forEach((p, index) => {
        highlightPage(index + 1);
      });
    }

    /**
     * Update the visibility and status of the floating search navigation.  When
     * there are search results, shows the navigation box and scrolls to the
     * first occurrence.  Otherwise hides the box.
     */
    function updateSearchNavigation() {
      // Deprecated: navigation handled within search bar
      return;
    }

    /**
     * Scroll to the specified search result index.  Updates active thumbnail and
     * page input field and highlights the relevant page.
     */
    function goToSearchResult(index) {
      if (index < 0 || index >= searchResults.length) return;
      const pageNum = searchResults[index];
      const target = document.querySelector(`.pdf-page[data-page-number="${pageNum}"]`);
      if (target) {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        updateActiveThumbnail(pageNum);
        renderPage(pageNum);
        currentPage = pageNum;
        updatePageInfo();
        currentSearchIndex = index;
        const infoEl = document.getElementById('searchBarInfo');
        if (infoEl) infoEl.textContent = `${currentSearchIndex + 1} / ${searchResults.length}`;
      }
    }

    function prevSearch() {
      if (!searchResults.length) return;
      let idx = currentSearchIndex - 1;
      if (idx < 0) idx = searchResults.length - 1;
      goToSearchResult(idx);
      // Update info display
      const infoEl = document.getElementById('searchBarInfo');
      if (infoEl) infoEl.textContent = `${currentSearchIndex + 1} / ${searchResults.length}`;
    }
    function nextSearch() {
      if (!searchResults.length) return;
      let idx = currentSearchIndex + 1;
      if (idx >= searchResults.length) idx = 0;
      goToSearchResult(idx);
      const infoEl = document.getElementById('searchBarInfo');
      if (infoEl) infoEl.textContent = `${currentSearchIndex + 1} / ${searchResults.length}`;
    }

    /**
     * Update the page navigation display with currentPage and totalPages.
     */
    function updatePageInfo() {
      const infoEl = document.getElementById('pageInfo');
      if (infoEl) {
        infoEl.textContent = `${currentPage} / ${totalPages || '--'}`;
      }
    }

    /**
     * Perform a search across the document.  Counts pages containing the
     * query and then highlights all occurrences.
     */
    async function performSearch(query) {
      currentQuery = query.trim().toLowerCase();
      const infoEl = document.getElementById('searchBarInfo');
      if (!currentQuery) {
        // clear search state
        searchResults = [];
        currentSearchIndex = -1;
        if (infoEl) infoEl.textContent = '';
        highlightAllPages();
        return;
      }
      let pagesWithMatch = 0;
      let totalMatches = 0;
      searchResults = [];
      currentSearchIndex = -1;
      for (const pageObj of pages) {
        const itemsText = pageObj.textContent.items.map(it => it.str).join(' ').toLowerCase();
        if (itemsText.includes(currentQuery)) {
          pagesWithMatch++;
          // Record page index for navigation
          searchResults.push(pages.indexOf(pageObj) + 1);
        }
        // Count occurrences per page
        let startIdx = 0;
        while (true) {
          const idx = itemsText.indexOf(currentQuery, startIdx);
          if (idx === -1) break;
          totalMatches++;
          startIdx = idx + currentQuery.length;
        }
      }
      if (infoEl) infoEl.textContent = `${currentSearchIndex === -1 ? 0 : currentSearchIndex + 1} / ${searchResults.length}`;
      highlightAllPages();
      // Scroll to first result if available
      if (searchResults.length > 0) {
        goToSearchResult(0);
      }
    }

    /**
     * Renders a single thumbnail for a given page number and replaces its
     * placeholder. This version is optimized for performance by rendering
     * at a low resolution.
     */
    async function renderThumbnail(pageNumber, thumbItemElement) {
      const pageObj = pages[pageNumber - 1];
      if (!pageObj || thumbCache[pageNumber]) return;

      const { page } = pageObj;
      const thumbWidth = 150; // Increased width for better quality
      const qualityFactor = 1.5;

      // Use the page's viewport to maintain aspect ratio
      const pageViewport = page.getViewport({ scale: 1.0 });
      const thumbScale = thumbWidth / pageViewport.width;
      const viewport = page.getViewport({ scale: thumbScale, rotation: rotation });

      const canvas = document.createElement('canvas');
      const ratio = window.devicePixelRatio || 1;
      
      // Set actual pixel dimensions for high quality
      canvas.width = viewport.width * ratio * qualityFactor;
      canvas.height = viewport.height * ratio * qualityFactor;
      
      // Set CSS display size
      canvas.style.width = viewport.width + 'px';
      canvas.style.height = viewport.height + 'px';
      
      const ctxThumb = canvas.getContext('2d');
      ctxThumb.scale(ratio * qualityFactor, ratio * qualityFactor);

      // Render the page to the canvas
      await page.render({ canvasContext: ctxThumb, viewport: viewport }).promise;
      
      // Cache the thumbnail
      thumbCache[pageNumber] = canvas.toDataURL();

      // Replace placeholder with the rendered canvas
      const placeholder = thumbItemElement.querySelector('.thumb-placeholder');
      if (placeholder) {
        // canvas.style.width = '80%';
        // canvas.style.height = 'auto';
        canvas.style.border = '1px solid #ccc';
        canvas.style.borderRadius = '4px';
        thumbItemElement.insertBefore(canvas, placeholder);
        thumbItemElement.removeChild(placeholder);
      }
    }

    /**
     * Generate placeholder thumbnails in the sidebar and set up an
     * IntersectionObserver to lazy-load the actual thumbnail images when
     * they scroll into view.
     */
    function generateThumbnails() {
      const thumbsContainer = document.getElementById('thumbsList');
      thumbsContainer.innerHTML = '';

      if (thumbnailObserver) {
        thumbnailObserver.disconnect();
      }

      const observerOptions = {
        root: thumbsContainer,
        rootMargin: '100px',
        threshold: 0.1
      };

      thumbnailObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const thumbItem = entry.target;
            const pageIndex = parseInt(thumbItem.dataset.pageNumber, 10);
            renderThumbnail(pageIndex, thumbItem);
            observer.unobserve(thumbItem);
          }
        });
      }, observerOptions);

      pages.forEach((pageObj, idx) => {
        const i = idx + 1;
        const thumbItem = document.createElement('div');
        thumbItem.classList.add('thumb-item');
        thumbItem.dataset.pageNumber = i;

        if (i === 1) {
          thumbItem.classList.add('active');
        }

        const thumbWidth = 100;
        const pageViewport = pageObj.page.getViewport({ scale: 1.0 });
        const aspectRatio = pageViewport.height / pageViewport.width;
        const thumbHeight = thumbWidth * aspectRatio;

        const placeholder = document.createElement('div');
        placeholder.classList.add('thumb-placeholder');
        placeholder.style.width = thumbWidth + 'px';
        placeholder.style.height = thumbHeight + 'px';
        placeholder.style.backgroundColor = '#e0e0e0';
        thumbItem.appendChild(placeholder);

        const label = document.createElement('div');
        label.classList.add('page-number');
        label.textContent = i;
        thumbItem.appendChild(label);

        thumbItem.addEventListener('click', () => {
          const targetDiv = document.querySelector(`.pdf-page[data-page-number="${i}"]`);
          if (targetDiv) {
            targetDiv.scrollIntoView({ behavior: 'smooth' });
            updateActiveThumbnail(i);
            renderPage(i);
            currentPage = i;
            updatePageInfo();
          }
        });

        thumbsContainer.appendChild(thumbItem);
        thumbnailObserver.observe(thumbItem);
      });
    }
    function updateActiveThumbnail(current) {
      const items = document.querySelectorAll('.thumb-item');
      items.forEach((item, idx) => {
        item.classList.toggle('active', idx + 1 === current);
      });
    }

    /**
     * Populate the outline as a nested list up to 3 levels deep.  Each item
     * scrolls to the corresponding page when clicked.
     */
    async function populateOutline() {
      const outline = await pdfDoc.getOutline();
      const container = document.getElementById('outlineList');
      container.innerHTML = '';
      function addItems(items, parent, level) {
        if (!items || level > 3) return;
        items.forEach(item => {
          const li = document.createElement('li');
          li.textContent = item.title;
          li.classList.add(`level-${level}`);
          li.addEventListener('click', async () => {
            if (item.dest) {
              const dest = await pdfDoc.getDestination(item.dest);
              const pageIndex = (await pdfDoc.getPageIndex(dest[0])) + 1;
              const target = document.querySelector(`.pdf-page[data-page-number="${pageIndex}"]`);
              if (target) {
                target.scrollIntoView({ behavior: 'smooth' });
                updateActiveThumbnail(pageIndex);
                renderPage(pageIndex);
                currentPage = pageIndex;
                updatePageInfo();
              }
            } else if (item.url) {
              window.open(item.url, '_blank');
            }
          });
          parent.appendChild(li);
          if (item.items) addItems(item.items, parent, level + 1);
        });
      }
      addItems(outline, container, 1);
    }

    /**
     * Determine file parameter from query string.
     */
    function getQueryParameter(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }

    /**
     * Load a PDF document from URL and initialise viewer.
     */
    function loadPdf(url) {
      const loader = document.getElementById('loader');
      loader.style.display = 'block';

      pdfjsLib.getDocument(url).promise.then(async pdf => {
        pdfDoc = pdf;
        const errEl = document.getElementById('errorMessage');
        if (errEl) errEl.style.display = 'none';
        
        await renderAllPages();
        
        setDownloadLink(url);
        currentPage = 1;
        updatePageInfo();
        
        loader.style.display = 'none';
      }).catch(err => {
        console.error('Error loading PDF:', err);
        const errEl = document.getElementById('errorMessage');
        if (errEl) {
          errEl.textContent = 'Failed to load PDF: ' + (err.message || err);
          errEl.style.display = 'block';
        }
        loader.style.display = 'none';
      });
    }

    /**
     * Set up the download link for the document.
     */
    function setDownloadLink(url) {
      document.getElementById('downloadBtn').onclick = () => {
        const a = document.createElement('a');
        a.href = url;
        a.download = url.split('/').pop();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      };
    }

    /**
     * Adjust the scale to fit the page width or height and re-render all pages.
     */
    async function fitToWidth() {
      if (!pdfDoc) return;
      fitMode = 'width';
      const firstPage = await pdfDoc.getPage(1);
      const viewport = firstPage.getViewport({ scale: 1.0, rotation: rotation });
      const viewer = document.getElementById('viewerContainer');
      const containerWidth = window.innerWidth - sidebar.clientWidth - 60; // 60 for padding
      scale = containerWidth / viewport.width;
      await renderAllPages();
      highlightAllPages();
    }
    async function fitToPage() {
      if (!pdfDoc) return;
      fitMode = 'page';
      const firstPage = await pdfDoc.getPage(1);
      const viewport = firstPage.getViewport({ scale: 1.0, rotation: rotation });
      const containerHeight = window.innerHeight - document.getElementById('toolbar').clientHeight - 40; // 40 for padding
      scale = containerHeight / viewport.height;
      await renderAllPages();
      highlightAllPages();
    }

    // Navigation via Prev/Next buttons
    function goToPrev() {
      if (currentPage > 1) {
        const newPage = currentPage - 1;
        const target = document.querySelector(`.pdf-page[data-page-number="${newPage}"]`);
        if (target) target.scrollIntoView({ behavior: 'smooth' });
        updateActiveThumbnail(newPage);
        renderPage(newPage);
        currentPage = newPage;
        updatePageInfo();
      }
    }
    function goToNext() {
      if (currentPage < pages.length) {
        const newPage = currentPage + 1;
        const target = document.querySelector(`.pdf-page[data-page-number="${newPage}"]`);
        if (target) target.scrollIntoView({ behavior: 'smooth' });
        updateActiveThumbnail(newPage);
        renderPage(newPage);
        currentPage = newPage;
        updatePageInfo();
      }
    }

    /**
     * Event listeners
     */
    document.getElementById('toggleSidebar').addEventListener('click', () => {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('collapsed');

      if (window.innerWidth <= 768) {
        const backdrop = document.getElementById('backdrop');
        backdrop.style.display = sidebar.classList.contains('collapsed') ? 'none' : 'block';
      } else {
        const divider = document.getElementById('divider');
        if (sidebar.classList.contains('collapsed')) {
          divider.style.display = 'none';
          document.getElementById('viewerContainer').style.margin = '0 auto';
        } else {
          divider.style.display = 'block';
          document.getElementById('viewerContainer').style.margin = '0';
        }
        // Re-render the PDF to fit the new container size
        fitToWidth();
      }
    });

    document.getElementById('backdrop').addEventListener('click', () => {
      document.getElementById('sidebar').classList.add('collapsed');
      document.getElementById('backdrop').style.display = 'none';
    });
    document.getElementById('outlineToggle').addEventListener('click', () => {
      document.getElementById('outlineToggle').classList.add('active');
      document.getElementById('thumbToggle').classList.remove('active');
      document.getElementById('outlineList').classList.add('active');
      document.getElementById('thumbsList').classList.remove('active');
    });
    document.getElementById('thumbToggle').addEventListener('click', () => {
      document.getElementById('thumbToggle').classList.add('active');
      document.getElementById('outlineToggle').classList.remove('active');
      document.getElementById('thumbsList').classList.add('active');
      document.getElementById('outlineList').classList.remove('active');
    });
    // Set default active tab: outline
    document.getElementById('outlineToggle').classList.add('active');
    document.getElementById('outlineList').classList.add('active');
    document.getElementById('thumbToggle').classList.remove('active');
    document.getElementById('thumbsList').classList.remove('active');

    // Adjust divider visibility based on initial sidebar state
    const initialSidebar = document.getElementById('sidebar');
    const initialDivider = document.getElementById('divider');
    const initialViewer = document.getElementById('viewerContainer');
    if (initialSidebar.classList.contains('collapsed')) {
      initialDivider.style.display = 'none';
      initialViewer.style.margin = '0 auto';
    } else {
      initialDivider.style.display = 'block';
      initialViewer.style.margin = '0';
    }

    document.getElementById('zoom_in').addEventListener('click', async () => {
      fitMode = 'custom';
      scale *= 1.25;
      await renderAllPages();
      highlightAllPages();
    });
    document.getElementById('zoom_out').addEventListener('click', async () => {
      fitMode = 'custom';
      scale /= 1.25;
      await renderAllPages();
      highlightAllPages();
    });
    document.getElementById('fit_width').addEventListener('click', fitToWidth);
    document.getElementById('fit_page').addEventListener('click', fitToPage);
    document.getElementById('fullscreenBtn').addEventListener('click', () => {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    });

    // Rotation controls
    document.getElementById('rotate_left').addEventListener('click', async () => {
      rotation = (rotation - 90 + 360) % 360;
      await renderAllPages();
      highlightAllPages();
    });
    document.getElementById('rotate_right').addEventListener('click', async () => {
      rotation = (rotation + 90) % 360;
      await renderAllPages();
      highlightAllPages();
    });

    // Search navigation controls
    // Bottom page navigation controls
    document.getElementById('pagePrev').addEventListener('click', () => {
      goToPrev();
    });
    document.getElementById('pageNext').addEventListener('click', () => {
      goToNext();
    });

    // Search bar controls
    const openSearchBtn = document.getElementById('openSearchBtn');
    const searchBar = document.getElementById('searchBar');
    const searchBarInput = document.getElementById('searchBarInput');
    const searchBarClose = document.getElementById('searchBarClose');
    const searchBarPrev = document.getElementById('searchBarPrev');
    const searchBarNext = document.getElementById('searchBarNext');

    function closeSearchBar() {
      searchBar.style.display = 'none';
      // Reset search state
      currentQuery = '';
      searchBarInput.value = '';
      performSearch('');
    }
    openSearchBtn.addEventListener('click', () => {
      if (searchBar.style.display === 'flex') {
        closeSearchBar();
      } else {
        searchBar.style.display = 'flex';
        searchBarInput.focus();
      }
    });
    searchBarClose.addEventListener('click', () => {
      closeSearchBar();
    });
    searchBarPrev.addEventListener('click', () => {
      prevSearch();
    });
    searchBarNext.addEventListener('click', () => {
      nextSearch();
    });
    // Debounce search input
    searchBarInput.addEventListener('input', () => {
      const value = searchBarInput.value;
      if (searchTimeout) clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => {
        performSearch(value);
      }, 300);
    });

    // Determine file parameter
    const fileParam = getQueryParameter('file');
    if (fileParam) {
      loadPdf(fileParam);
    } else {
      loadPdf(DEFAULT_URL);
    }

    // Divider drag functionality
    let isDraggingDivider = false;
    const divider = document.getElementById('divider');
    const sidebarEl = document.getElementById('sidebar');
    const containerEl = document.getElementById('container');
    divider.addEventListener('mousedown', e => {
      isDraggingDivider = true;
      document.body.style.cursor = 'col-resize';
    });
    document.addEventListener('mousemove', e => {
      if (!isDraggingDivider) return;
      // compute relative position within container
      const rect = containerEl.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      let newPercent = (offsetX / rect.width) * 100;
      // constrain between 10% and 70%
      newPercent = Math.max(10, Math.min(70, newPercent));
      sidebarEl.style.width = newPercent + '%';
      // update CSS variable
      document.documentElement.style.setProperty('--sidebar-width', newPercent + '%');
    });
    document.addEventListener('mouseup', () => {
      if (isDraggingDivider) {
        isDraggingDivider = false;
        document.body.style.cursor = '';
      }
    });
  </script>
</body>
</html>
